#!/bin/bash
#
# xrootd/cmsd	This shell script takes care of starting and stopping
#		Qserv xrootd/cmsd instances.
#
# description: xrootd is the filesystem which allow Qserv master to \
# communicate with Qserv workers.\
# It is composed of two services : xrootd and cmsd
# Note

### BEGIN INIT INFO
# Provides: xrootd cmsd
# Short-Description: start and stop xrootd/cmsd
# Description: qms is the Qserv Meta Service. It is used by Qserv master
#              in order to get accurate informations about loaded datasets.
#              Note that Qserv service won't start if QMS databse is empty.
### END INIT INFO


XROOTD_CONFIG=%(QSERV_BASE_DIR)s/etc/lsp.cf
XROOTD_INSTANCE_NAME="worker"

PID_DIR=%(QSERV_PID_DIR)s/${XROOTD_INSTANCE_NAME}
LOG_DIR=%(QSERV_LOG_DIR)s/

SERVICES=(xrootd cmsd)

declare -A SERVICE_NAMES
SERVICE_NAMES=(["xrootd"]="Qserv xrootd" ["cmsd"]="Qserv cmsd")
declare -A PIDFILES
PIDFILES=(["xrootd"]=${PID_DIR}/xrootd.pid  ["cmsd"]=${PID_DIR}/cmsd.pid)
declare -A BINARIES
BINARIES=(["xrootd"]=%(QSERV_BASE_DIR)s/bin/xrootd  ["cmsd"]=%(QSERV_BASE_DIR)s/bin/cmsd)
declare -A LOGFILES
LOGFILES=(["xrootd"]=${LOG_DIR}/xrootd.log  ["cmsd"]=${LOG_DIR}/cmsd.log)


export QSW_XRDQUERYPATH="/q"
export QSW_DBSOCK="%(MYSQLD_SOCK)s"
export QSW_MYSQLDUMP="%(QSERV_BASE_DIR)s/bin/mysqldump"
QSW_SCRATCHPATH="%(QSERV_BASE_DIR)s/tmp"
QSW_SCRATCHDB="qservScratch"
export QSW_RESULTPATH="%(XROOTD_RUN_DIR)s/result"
export LD_LIBRARY_PATH="%(XROOTD_RUN_DIR)s;%(QSERV_BASE_DIR)s/lib"


start_service() {
    SERVICE=${SERVICE_NAMES[$1]}
    PIDFILE=${PIDFILES[$1]}
    BINARY=${BINARIES[$1]}
    LOGFILE=${LOGFILES[$1]}
    echo
    echo $"Starting ${SERVICE} :"
    [ -x ${XROOTD_START} ] || exit 5
    [ -f ${XROOTD_CONFIG} ] || exit 6

    if [ -f ${PIDFILE} ]
    then
	echo $"${SERVICE} is already up (${PIDFILE} exists). Aborting start command."
	exit 0
    fi

    ${BINARY} -c ${XROOTD_CONFIG} -l ${LOGFILE} -n ${XROOTD_INSTANCE_NAME} &
    PID=$!
    RETVAL=$?
    if [ $RETVAL -eq 0 ]
    then
	echo $"${SERVICE} started successfully (PID: ${PID})"
    fi
    return $RETVAL
}

stop_service() {
    SERVICE=${SERVICE_NAMES[$1]}
    PIDFILE=${PIDFILES[$1]}
    echo $"Stopping ${SERVICE} :"
    if [ ! -f ${PIDFILE} ]
    then
	echo $"${SERVICE} is already down (${PIDFILE} doesn't exists). Aborting stop command."
	exit 0
    fi
    PID=`cat ${PIDFILE}`
    kill ${PID}
    RETVAL=$?
    if [ $RETVAL -eq 0 ]
    then
	rm -f ${PIDFILE}
	echo $"${SERVICE} stopped successfully (PID: ${PID})"
    fi
    return $RETVAL
}

status() {
    for i in "${SERVICES[@]}"
    do
	SERVICE=${SERVICE_NAMES[$i]}
	PIDFILE=${PIDFILES[$i]}
	if [ -f ${PIDFILE} ]
	then
	    PID=`cat ${PIDFILE}`
	    echo $"${SERVICE} is up, process : ${PID}"
	else
	    echo $"${SERVICE} is down"
	fi
    done
    exit 0
}

start() {
    start_service "xrootd"
    # cmsd won't start if no manager is specified
    %(COMMENT_MONO_NODE)s start_service "cmsd"
}

stop() {
    stop_service "xrootd"
    # cmsd won't start if no manager is specified
    %(COMMENT_MONO_NODE)s stop_service "cmsd"
}

# See how we were called.
case "$1" in
  start)
	start
	;;
  stop)
	stop
	;;
  status)
	status $prog
	;;
  restart)
	stop
	start
	;;
  try-restart|condrestart)
	if status $prog > /dev/null; then
	    stop
	    start
	fi
	;;
  *)
	echo $"Usage: $0 {start|stop|status|restart|try-restart}"
	exit 2
esac

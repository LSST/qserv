#!/usr/local/bin/perl -w

use strict;
use Getopt::Long;

Getopt::Long::config('bundling_override');
my %opts = ();
GetOptions( \%opts, 
	"debug",
	"help|h",
	"status|s",
	"stop",
	"start",
	"load",
	"source=s",
	"table=s",
	"output=s",
	"partition",
	"test"
);
usage(1) if ($Getopt::Long::error); 
usage(0) if ($opts{'help'});

my $debug = $opts{'debug'} || 0;

my $install_dir = "INSTALLDIR";

#mysql variables
my $mysqld_sock = "$install_dir/var/lib/mysql/mysql.sock";

if( $opts{'status'} ) {
	if( check_mysqld() ) {
		print "Mysql server up and running.\n";
	} else {
		print "Mysql server not running.\n";
	}

	if( check_proxy() ) {
		print "Mysql proxy up and running.\n";
	} else {
		print "Mysql proxy not running.\n";
	}

	if( check_xrootd() ) {
		print "Xrootd server up and running.\n";
	} else {
		print "Xrootd server not running.\n";
	}

	if( check_qserv() ) {
		print "Qserv server up and running.\n";
	} else {
		print "Qserv server not running.\n";
	}

} elsif( $opts{'stop'} ) {
	
	print "Stopping mysql-proxy\n";
	stop_proxy();
	print "Stopping xrootd\n";
	stop_xrootd();
	print "Stopping mysqld\n"; 
	stop_mysqld();
	print "Stopping qserv\n"; 
	stop_qserv();
	
} elsif( $opts{'start'} ) {

	start_proxy();
	start_xrootd();
	start_mysqld();
	start_qserv();
	
} elsif( $opts{'partition'} ) {

	#need to partition raw data for loading into qserv.
	unless( $opts{'source'} ) {
		print "Error: you need to set the path to the source data with the --source option.\n";
		exit(1);
	}
	unless( $opts{'table'} ) {
		print "Error: you need to specify the table name for the source data with the --table option.\n";
		exit(1);
	}
	unless( $opts{'output'} ) {
		print "Error: you need to specify the output path with the --output option.\n";
		exit(1);
	}
	
	partition_data( $opts{'source'}, $opts{'output'}, $opts{'table'} );
	
} elsif( $opts{'load'} ) {

        #need to partition raw data for loading into qserv.
        unless( $opts{'source'} ) {
                print "Error: you need to set the path to the source data with the --source option.\n";
               	exit(1);
        }
        unless( $opts{'table'} ) {
                print "Error: you need to specify the table name for the source data with the --table option.\n";
               	exit(1);
        }
       	unless( $opts{'output'} ) {
                print "Error: you need to specify the output path with the --output option.\n";
                exit(1);
        }

	#need to load data into qserv
	load_data( $opts{'source'}, $opts{'output'}, $opts{'table'} );
}


#############################################################

sub check_sql_server {
	my( $command ) = @_;

	print "Testing sql with command $command\n" if( $debug );
	
	my $testsql = "/tmp/tmp.sql";
	create_test_sql( $testsql );
	
	#try through the proxy to see if it can talk to mysql server.
	my @reply = `$command < $testsql 2>&1`;
	
	print "@reply\n" if( $debug );
	
	if( $reply[0] =~ /Database/ ) {
		return 1;
	} else {
		return 0;
	}
	
	unlink "$testsql";
	
}

sub create_test_sql {
	my( $testsql ) = @_;
	
	#create tmp sql file
	open TMPFILE, ">$testsql";
	print TMPFILE "show databases;\n";
	close TMPFILE;
	
}

sub check_proxy {

	return check_sql_server( "mysql --port=4040 --protocol=TCP" );

}

sub check_mysqld {

	if( -e "$mysqld_sock" ) {
		return check_sql_server( "mysql -S $mysqld_sock -u root" );
	} else {
		return 0;
	}
}

sub check_xrootd {
	
	return check_ps( "xrootd -c" );

}

sub check_qserv {
	
	return check_ps( "startQserv" );

}

sub check_ps {
	my( $test_string ) = @_;
	#print "$test_string\n";
	
	my @reply = `ps x`;
	#print @reply;
	my @stuff = grep /$test_string/, @reply;
	#print @stuff;
	
	if( @stuff ) {
		my( $pid ) = $stuff[0] =~ /^\s*(\d+) /;
		return $pid;
	} else {
		return 0;
	}
}

sub stop_qserv {

	stop_ps( "startQserv" );

}

sub stop_xrootd {

	stop_ps( "xrootd -c" );

}

sub stop_mysqld {

	stop_ps( "mysqld --basedir" );

}

sub stop_proxy {

	stop_ps( "mysql-proxy" );

}

sub stop_ps {
	my( $test_string ) = @_;
	#print "$test_string\n";
	
	my $pid = check_ps( $test_string );
	#print "pid to stop -- $pid\n";
	if( $pid ) {
		if( $opts{'test'} ) {
			print "I would now kill process $pid.\n";
		} else {
			`kill $pid`;
		}
	}

}

sub start_proxy {

	system("$install_dir/start_mysqlproxy");

}

sub start_mysqld {

	system("$install_dir/bin/mysqld_safe &");

}

sub start_qserv {

	system("$install_dir/start_qserv");

}

sub start_xrootd {

	system("$install_dir/start_xrootd");
	
}

sub partition_data {
	my( $source_dir, $output_dir, $tablename ) = @_;
	
	my( $dataname ) = $source_dir =~ m!/([^/]+)$!;
	
	if( -d "$output_dir" ) {
		chdir "$output_dir";
	} else {
		print "Error: the output dir $output_dir doesn't exist.\n";
	}

	#need to have the various steps to partition data
	my $command = "$install_dir/bin/python $install_dir/qserv/master/examples/partition.py ".
		"-P$tablename -t 2 -p 4 $source_dir/${tablename}.txt -S 10 -s 2";
	if( $opts{'test'} ) {
		print "$command\n";
	} else {
		`$command`;
	}
}

sub load_data {
	my( $source_dir, $location, $tablename ) = @_;
	
	#create database if it doesn't exist
	`$install_dir/bin/mysql -S $install_dir/var/lib/mysql/mysql.sock -u root -e 'Create database if not exists LSST;'`;
	
	#check on the table def, and add need columns
	print "Copy and changing $source_dir/${tablename}.sql\n";
	my $tmptable = lc $tablename;
	`cp $source_dir/${tablename}.sql $install_dir/tmp`;
	`perl -pi -e 's,^.*_chunkId.*\n,,' $install_dir/tmp/${tablename}.sql`;
	`perl -pi -e 's,^.*_subChunkId.*\n,,' $install_dir/tmp/${tablename}.sql`;
	`perl -pi -e 's!^\(\\s*PRIMARY\)!  chunkId int\(11\) default NULL,\\n\\1!' $install_dir/tmp/${tablename}.sql`;
	`perl -pi -e 's!^\(\\s*PRIMARY\)!  subChunkId int\(11\) default NULL,\\n\\1!' $install_dir/tmp/${tablename}.sql`;
	`perl -pi -e 's!^\\s*PRIMARY KEY\\s+\\(.*\\)!  PRIMARY KEY \(${tmptable}Id, subChunkId\)!' $install_dir/tmp/${tablename}.sql`;

	#regress through looking for partitioned data, create loading script
	open LOAD, ">$install_dir/tmp/${tablename}_load.sql";
	
	my %chunkslist = ();
	opendir DIR, "$location";
	my @dirslist = readdir DIR;
	closedir DIR;
	
	foreach my $dir ( @dirslist ) {
		next if( $dir =~ /^\./ );
		
		if( $dir =~ /^stripe/ ) {
			opendir DIR, "$location/$dir";
			my @filelist = readdir DIR;
			closedir DIR;
			
			foreach my $file ( @filelist ) {
				if( $file =~ /(\w+)_(\d+).csv/ ) {
					if( $1 eq $tablename ) {
					print LOAD "CREATE TABLE IF NOT EXISTS ${1}_$2 LIKE $tablename;\n";
					print LOAD "LOAD DATA INFILE '$location/$dir/$file' INTO TABLE ${1}_$2 FIELDS TERMINATED BY ',';\n";

					$chunkslist{$2} = 1;
					}
				}
			}
		}
	}
	print LOAD "CREATE TABLE IF NOT EXISTS ${tablename}_1234567890 LIKE $tablename;\n";
	close LOAD;
	
	#load the data into the mysql instance
	print "Loading data, this make take awhile...\n";
	`$install_dir/bin/mysql -S $install_dir/var/lib/mysql/mysql.sock -u root LSST < $install_dir/tmp/${tablename}.sql`;
	`$install_dir/bin/mysql -S $install_dir/var/lib/mysql/mysql.sock -u root LSST < $install_dir/tmp/${tablename}_load.sql`;
		
	#create the empty chunks file
	create_emptychunks( \%chunkslist );
	
	#create a setup file
	unless( -e "$install_dir/etc/setup.cnf" ) {
		open SETUP, ">$install_dir/etc/setup.cnf";
		print SETUP "host:localhost\n";
		print SETUP "port:4040\n";
		print SETUP "user:root\n";
		print SETUP "pass:\n";
		print SETUP "sock:$install_dir/var/lib/mysql/mysql.sock\n";
		close SETUP;
	}

	#regester the database, export
	my $command = "$install_dir/qserv/worker/tools/qsDbTool ";
	$command .= "-a $install_dir/etc/setup.cnf -i 1 ";
	$command .= "register LSST Object";
	print "Command: $command\n";
	`$command`;
	
	$command = "$install_dir/qserv/worker/tools/qsDbTool ";
	$command .= "-a $install_dir/etc/setup.cnf -i 1 -b $install_dir/xrootd-run ";
	$command .= "export LSST";
        print "Command: $command\n";
	`$command`;
	
}

sub create_emptychunks {
	my( $chunkslist ) = @_;
		
	open CHUNKS, ">$install_dir/etc/emptyChunks.txt";
	for( my $i = 0; $i < 1000; $i++ ) {
		unless( defined $chunkslist->{$i} ) {
			print CHUNKS "$i\n";
		}
	}
	close CHUNKS;
	
}


#help report for the --help option
sub usage {
  my($exit, $message) = @_;

        my($bin) = ($0 =~ m!([^/]+)$!);
        print STDERR $message if defined $message;
        print STDERR <<INLINE_LITERAL_TEXT;     
usage: $bin [options]
  Export merged collections to SLAC.

Options are:
      --debug     Print out debug messages.
  -h, --help      Print out this help message.
  -s, --status    Print out the status of the server processes.
      --stop      Stop the servers.
	  --start     Start the servers.

Examples: $bin --status

Comments to Douglas Smith <douglas\@slac.stanford.edu>.
INLINE_LITERAL_TEXT

	       exit($exit) if defined $exit;

}

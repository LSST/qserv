/*
 * LSST Data Management System
 *
 * This product includes software developed by the
 * LSST Project (http://www.lsst.org/).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the LSST License Statement and
 * the GNU General Public License along with this program.  If not,
 * see <http://www.lsstcorp.org/LegalNotices/>.
 */
#ifndef LSST_QSERV_WBASE_TRANSMITDATA_H
#define LSST_QSERV_WBASE_TRANSMITDATA_H

// System headers
#include <atomic>
#include <memory>
#include <string>

// 3rd party headers
#include <mysql/mysql.h>

// Qserv headers
#include "proto/ProtoHeaderWrap.h"
#include "qmeta/types.h"

namespace google::protobuf {
class Arena;
}  // namespace google::protobuf

// This header declarations
namespace lsst::qserv {

namespace util {
class MultiError;
}

namespace xrdsvc {
class StreamBuffer;
}

namespace wbase {

class Task;

/// This class stores properties for one column in the schema.
class SchemaCol {
public:
    SchemaCol() = default;
    SchemaCol(SchemaCol const&) = default;
    SchemaCol& operator=(SchemaCol const&) = default;
    SchemaCol(std::string name, std::string sqltype, int mysqltype)
            : colName(name), colSqlType(sqltype), colMysqlType(mysqltype) {}
    std::string colName;
    std::string colSqlType;  ///< sqltype for the column
    int colMysqlType = 0;    ///< MySQL type number
};

/// This class is used to store information needed for one transmit.
/// The data may be for result rows or an error message.
class TransmitData {
public:
    using Ptr = std::shared_ptr<TransmitData>;

    TransmitData() = delete;
    TransmitData(TransmitData const&) = delete;
    TransmitData& operator=(TransmitData const&) = delete;

    /// Create a transmitData object
    static Ptr createTransmitData(qmeta::CzarId const& czarId_, std::string const& idStr);

    /// Initialize the result.
    void initResult(Task& task, std::vector<SchemaCol>& schemaCols);

    /// @return a string representation of this transmit object's header
    ///         generated by protobufs.
    /// 'seq' and 'scsSeq' are sequence numbers to help identify the
    ///    origin of messages on the czar.
    std::string getHeaderString(uint32_t seq, int scsSeq);

    /// Attach the header for the next message to this message. If
    /// 'reallyLast' is true, this is the last transmit in the message, so
    /// a special header is attached.
    /// 'seq' and 'scsSeq' are sequence numbers to help identify the
    ///    origin of messages on the czar.
    void attachNextHeader(TransmitData::Ptr const& nextTr, bool reallyLast, uint32_t seq, int scsSeq);

    /// @return a StreamBuffer object containing what was in _dataMsg.
    /// Note: this function invalidates _dataMsg.
    std::shared_ptr<xrdsvc::StreamBuffer> getStreamBuffer(std::shared_ptr<Task> const& task);

    /// @return the protobuf string for the header.
    std::string makeHeaderString(bool reallyLast, uint32_t seq, int scsSeq);

    qmeta::CzarId getCzarId() const { return _czarId; }

    /// Fill one row in the _result msg from one row in MYSQL_RES* 'mResult'
    /// If the message has gotten larger than the desired message size,
    /// return false.
    /// @return false if there ARE MORE ROWS left in mResult.
    ///         true if there are no more rows remaining in mResult.
    bool fillRows(MYSQL_RES* mResult, int numFields, size_t& sz);

    /// Add the schema to this TransmitData object.
    /// The schema is always the same for a query, so it will only be added the
    /// first time this function is called for the instance.
    void addSchemaCols(std::vector<SchemaCol>& schemaCols);

    /// Use the information collected in _result and multiErr to build _dataMsg.
    void buildDataMsg(Task const& task, bool largeResult, util::MultiError& multiErr);

    /// @return true if tData has an error message in _result.
    bool hasErrormsg() const;

    /// @return the size of the result in bytes.
    int getResultSize() const;

    /// Return the number of rows in the result.
    int getResultRowCount() const;

    std::string getIdStr() const { return _idStr; }

    /// @return a log worthy description of this object.
    std::string dump() const {
        std::lock_guard<std::mutex> lock(_trMtx);
        return _dump();
    }

private:
    TransmitData(qmeta::CzarId const& czarId, std::shared_ptr<google::protobuf::Arena> const& arena,
                 std::string const& idStr);

    /// Create a header for an empty result using our arena.
    /// This does not set the 'header' member of this object as there is a
    /// case where an empty header is needed to append to the result.
    /// This should only be appended to the result of this->result as
    /// the '_arena' will be deallocated when this object is destroyed.
    /// Note: _trMtx must be held before calling this.
    proto::ProtoHeader* _createHeader();

    /// Note: _trMtx must be held before calling this.
    std::string _makeHeaderString(bool reallyLast, uint32_t seq, int scsSeq);

    /// @see buildDataMsg
    /// Note: _trMtx must be held before calling this.
    void _buildDataMsg(Task const& task, bool largeResult, util::MultiError& multiErr);

    ////////////////////////////////////////////////////
    // Methods used by QueryRunner to build dataMsg
    void _buildHeader(bool largeResult);

    /// @see addSchemaCols
    /// Note: _trMtx must be held before calling this.
    void _addSchemaCols(std::vector<SchemaCol>& schemaCols);

    /// @see dump()
    std::string _dump() const;

    // proto objects are instantiated as part of google protobuf arenas
    // and should not be deleted. They are deleted when the arena is deleted.
    proto::ProtoHeader* _header = nullptr;
    proto::Result* _result = nullptr;

    /// Serialized string for result that is appended with wrapped string for headerNext.
    std::string _dataMsg;

    qmeta::CzarId const _czarId;

    mutable std::mutex _trMtx;                ///< Protects all private member variables.
    std::atomic<bool> _schemaColsSet{false};  ///< Set to true when schema columns are set.

    unsigned int _rowCount = 0;  ///< Number of rows in the _result so far.
    size_t _tSize = 0;           ///< Approximate number of bytes in the _result so far.

    /// Create a result using our arena.
    /// This does not set the 'result' member of this object for consistency.
    proto::Result* _createResult();

    std::shared_ptr<google::protobuf::Arena> _arena;

    std::string const _idStr;

    int const _trSeq;  ///< Identifier for this object, used for debugging.

    std::shared_ptr<util::InstanceCount> _icPtr;  // LockupDB
};

}  // namespace wbase
}  // namespace lsst::qserv

#endif  // LSST_QSERV_WBASE_TRANSMITDATA_H

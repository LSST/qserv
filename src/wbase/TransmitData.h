/*
 * LSST Data Management System
 *
 * This product includes software developed by the
 * LSST Project (http://www.lsst.org/).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the LSST License Statement and
 * the GNU General Public License along with this program.  If not,
 * see <http://www.lsstcorp.org/LegalNotices/>.
 */
#ifndef LSST_QSERV_WBASE_TRANSMITDATA_H
#define LSST_QSERV_WBASE_TRANSMITDATA_H

// System headers
#include <atomic>
#include <memory>
#include <string>

// 3rd party headers
#include <mysql/mysql.h>

// Qserv headers
#include "proto/ProtoHeaderWrap.h"
#include "qmeta/types.h"


namespace google {
namespace protobuf {
class Arena;
}}

// This header declarations
namespace lsst {
namespace qserv {

namespace util {
class MultiError;
}

namespace xrdsvc {
class StreamBuffer;
}

namespace wbase {

class Task;


/// This class stores properties for one column in the schema.
class SchemaCol {
public:
    SchemaCol() = default;
    SchemaCol(SchemaCol const&) = default;
    SchemaCol& operator=(SchemaCol const&) = default;
    SchemaCol(std::string name, std::string sqltype, int mysqltype) :
        colName(name), colSqlType(sqltype), colMysqlType(mysqltype) {
    }
    std::string colName;
    std::string colSqlType; ///< sqltype for the column
    int colMysqlType = 0; ///< MySQL type number
};


/// This class is used to store information needed for one transmit
class TransmitData {
public:
    using Ptr = std::shared_ptr<TransmitData>;

    TransmitData() = delete;
    TransmitData(TransmitData const&) = delete;
    TransmitData& operator=(TransmitData const&) = delete;

    /// Create a transmitData object
    static Ptr createTransmitData(qmeta::CzarId const& czarId_);

    /* &&&
    /// Create a header for an empty result using our arena.
    /// This does not set the 'header' member of this object as there is a
    /// case where an empty header is needed to append to the result.
    /// This should only be appended to the result of this->result as
    /// the '_arena' will be deallocated when this object is destroyed.
    proto::ProtoHeader* createHeader();
    &&& */

    /// @return a string representation of this transmit object's header
    ///         generated by protobufs.
    /// 'seq' and 'scsSeq' are sequence numbers to help identify the
    ///    origin of messages on the czar.
    std::string getHeaderString(uint32_t seq, int scsSeq);

    /// Attach the header for the next message to this message. If
    /// 'reallyLast' is true, this is the last transmit in the message, so
    /// a special header is attached.
    /// 'seq' and 'scsSeq' are sequence numbers to help identify the
    ///    origin of messages on the czar.
    void attachNextHeader(TransmitData::Ptr const& nextTr, bool reallyLast, uint32_t seq, int scsSeq);

    /// @return a StreamBuffer object containing what was in _dataMsg.
    /// Note: this function invalidates _dataMsg.
    std::shared_ptr<xrdsvc::StreamBuffer> getStreamBuffer();

    /// @return the protobuf string for the header.
    std::string makeHeaderString(bool reallyLast, uint32_t seq, int scsSeq);

    qmeta::CzarId getCzarId() const { return _czarId; }
    bool getScanInteractive() const { return _scanInteractive; }

    /// Initialize the result.
    void initResult(Task& task, std::vector<SchemaCol>& schemaCols);

    /// Fill one row in the _result msg from one row in MYSQL_RES* 'mResult'
    /// If the message has gotten larger than the desired message size,
    /// return false.
    /// @return false if there ARE MORE ROWS left in mResult.
    ///         true if there are no more rows remaining in mResult.
    bool fillRows(MYSQL_RES* mResult, int numFields, size_t &sz);

    //&&& doc
    void addSchemaCols(std::vector<SchemaCol>& schemaCols);

    /// Use the information collected in _result and multiErr to build _dataMsg.
    void buildDataMsg(Task const& task, bool largeResult, util::MultiError& multiErr);

    /// @return true if tData has an error message in _result.
    bool hasErrormsg() const;

    /// Make certain endnodata is false.
    void clearEndNoData(); //&&& delete

    /// Set values that need to be set just before queuing the TransmitData
    /// to be sent.
    void setFinalValues(bool scanInteractive, bool erred, bool largeResult);

private:
    TransmitData(qmeta::CzarId const& czarId, std::shared_ptr<google::protobuf::Arena> const& arena);

    /// Create a header for an empty result using our arena.
    /// This does not set the 'header' member of this object as there is a
    /// case where an empty header is needed to append to the result.
    /// This should only be appended to the result of this->result as
    /// the '_arena' will be deallocated when this object is destroyed.
    /// Note: _trMtx must be held before calling this.
    proto::ProtoHeader* _createHeader();

    /// Note: _trMtx must be held before calling this.
    std::string _makeHeaderString(bool reallyLast, uint32_t seq, int scsSeq);

    /// @see buildDataMsg
    /// Note: _trMtx must be held before calling this.
    void _buildDataMsg(Task const& task, bool largeResult, util::MultiError& multiErr);

    ////////////////////////////////////////////////////
    // Methods used by QueryRunner to build dataMsg
    void _buildHeader(bool largeResult);

    /// @see addSchemaCols
    /// Note: _trMtx must be held before calling this.
    void _addSchemaCols(std::vector<SchemaCol>& schemaCols);

    // proto objects are instantiated as part of google protobuf arenas
    // and should not be deleted. They are deleted when the arena is deleted.
    proto::ProtoHeader* _header = nullptr;
    proto::Result* _result = nullptr;

    /// Serialized string for result that is appended with wrapped string for headerNext.
    std::string _dataMsg;

    qmeta::CzarId const _czarId;
    std::atomic<bool> _erred{false};
    std::atomic<bool> _largeResult{false};
    std::atomic<bool> _scanInteractive{false};

    std::mutex _trMtx; ///< Protects all private member variables.
    std::atomic<bool> _schemaColsSet{false}; ///< Set to true when schema columns are set.

    unsigned int _rowCount = 0; ///< Number of rows in the _result so far.
    size_t _tSize = 0; ///< Approximate number of bytes in the _result so far.

    /// Create a result using our arena.
    /// This does not set the 'result' member of this object for consistency.
    proto::Result* _createResult();

    std::shared_ptr<google::protobuf::Arena> _arena;
};

}}} // namespace lsst::qserv::wbase

#endif // LSST_QSERV_WBASE_TRANSMITDATA_H
